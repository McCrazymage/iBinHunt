(*
 Owned and copyright BitBlaze, 2007. All rights reserved.
 Do not copy, disclose, or distribute without explicit written
 permission.
*)
(**
   An interface to program state files generated by TEMU. 
   
   @author Zhenkai Liang, Juan Caballero
*)

open Vine

type userRegs = {
  ebx : int32; 
  ecx : int32; 
  edx : int32; 
  esi : int32; 
  edi : int32; 
  ebp : int32; 
  eax : int32; 
  xds : int32; 
  xes : int32; 
  xfs : int32;
  xgs : int32; 
  orig_eax : int32; 
  eip : int32;
  xcs : int32; 
  eflags : int32; 
  esp : int32; 
  xss : int32; 
}

(* A range of addresses. The range is inclusive 
    (both first and last belong to the range *)
type range = {
  first : int32; 
  last  : int32; 
  pos : int64; 
}

let register_rec_size = 68L (* 17 * 4 *)

(* Unserialize registers from input channel *)
let read_registers ic = 
  let tc = IO.input_channel ic in
  let ebx = IO.read_real_i32 tc in
  let ecx = IO.read_real_i32 tc in
  let edx = IO.read_real_i32 tc in
  let esi = IO.read_real_i32 tc in
  let edi = IO.read_real_i32 tc in
  let ebp = IO.read_real_i32 tc in
  let eax = IO.read_real_i32 tc in 
  let xds = IO.read_real_i32 tc in
  let xes = IO.read_real_i32 tc in
  let xfs = IO.read_real_i32 tc in
  let xgs = IO.read_real_i32 tc in
  let orig_eax = IO.read_real_i32 tc in
  let eip = IO.read_real_i32 tc in
  let xcs = IO.read_real_i32 tc in
  let eflags = IO.read_real_i32 tc in
  let esp = IO.read_real_i32 tc in
  let xss = IO.read_real_i32 tc in
    { ebx = ebx; ecx = ecx; edx = edx; esi = esi; edi = edi; ebp = ebp;
      eax = eax; xds = xds; xes = xes; xfs = xfs; xgs = xgs; 
      orig_eax = orig_eax;  eip = eip; xcs = xcs; eflags = eflags; 
      esp = esp; xss = xss; }

(* Read list of blocks in input channel *)
let read_block_info ic = 
  let () = LargeFile.seek_in ic register_rec_size in
  let read_block ic =
    let tc = IO.input_channel ic in 
    let first = IO.read_real_i32 tc in
    let last = IO.read_real_i32 tc in
    let pos = LargeFile.pos_in ic in
    let blocksize = Int32.sub last first in
    let () = LargeFile.seek_in ic
      (Int64.add pos (Int64.of_int32 blocksize))
    in
    let last = Int32.pred last in
      {first = first; last = last; pos = pos;}
  in
  let rec read_all_blocks ic =
    try 
      let blk = read_block ic in
	blk :: read_all_blocks ic
    with 
	IO.No_more_input 
      | End_of_file -> []
  in
    read_all_blocks ic

(* Read a memory range between the first and last addresses (inclusive)
     Returns a list of characters
*)
let read_memory_range first last blkinfo ic =
  try 
    let blk = List.find 
      (fun blk -> (blk.first<=first) && (blk.last>=last)) 
      blkinfo
    in
    let offset = Int32.sub first blk.first in
    let offset = Int64.of_int32 offset in
    let pos = Int64.add blk.pos offset in
    let () = LargeFile.seek_in ic pos in
    let tc = IO.input_channel ic in
    let buf = IO.nread tc (Int32.to_int (Int32.succ (Int32.sub last first))) in
      ExtString.String.explode buf
  with
      Not_found -> []

(* Read all memory ranges (without content) in state file *)
let read_memory_ranges filename =
  let ic = open_in filename in
  let blkinfo = read_block_info ic in
  let () = close_in ic in
  blkinfo

(* Read a memory range with content from state file *)
let read_memory_range_from_file first last filename =
  let ic = open_in filename in
  let blkinfo = read_block_info ic in
  let memlist = read_memory_range first last blkinfo ic in
  let () = close_in ic in
    memlist

;;

(* Generate range inits from state file *)
let generate_range_inits state_file ranges memvar =
  List.fold_left
    (fun mem_inits ((first:int64), (last:int64)) ->
       let data = 
	 read_memory_range_from_file
	   (Int64.to_int32 first)
	   (Int32.succ (Int64.to_int32 last))
	   state_file
       in
       let mem_inits, next_addr = 
	 List.fold_left
	   (fun (mem_inits, next_addr) byte ->
	      let lhs = Mem(memvar,
			    const_of_int64 addr_t next_addr,
			    REG_8) in
	      let rhs = const_of_int REG_8 (int_of_char byte) in
	      Move(lhs,rhs)::mem_inits, Int64.succ next_addr
	   ) 
	   (mem_inits, first)
	   data
       in
       (* assert(Int64.pred next_addr = last); *)
       mem_inits
    ) 
    []
    ranges

(* Initialize memory regions from state file. *)
let add_range_inits_to_prog prog memvar state_file ranges =
  let (dl,sl) = prog in 
  let mem_inits = generate_range_inits state_file ranges memvar in
  (dl, Block([],mem_inits)::sl)


